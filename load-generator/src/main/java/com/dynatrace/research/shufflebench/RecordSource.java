package com.dynatrace.research.shufflebench;

import com.dynatrace.research.shufflebench.record.Record;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Consumer;
import java.util.function.Supplier;

import static java.util.Objects.requireNonNull;

public class RecordSource {

  private static final Logger LOGGER = LogManager.getLogger(RecordSource.class);
  private final Supplier<Record> generator;

  private final String name;

  private static final AtomicLong GLOBAL_COUNTER = new AtomicLong();
  private final AtomicLong counter = new AtomicLong();
  private final ScheduledFuture<?> future;

  public RecordSource(
      ScheduledExecutorService scheduledExecutorService,
      double recordsPerSecond,
      Consumer<Record> consumer,
      Supplier<Record> generator,
      String name) {
    this.generator = generator;
    requireNonNull(consumer);
    this.name = requireNonNull(name);
    long delayInNanos = (long) (1e9 / recordsPerSecond);
    future =
        scheduledExecutorService.scheduleAtFixedRate(
            () -> {
              final long numGeneratedRecordsGlobal = GLOBAL_COUNTER.incrementAndGet();
              final long numGeneratedRecords = counter.incrementAndGet();
              final Record record = generator.get();
              LOGGER.debug(
                  "record generated by {} (local counter = {}, global counter = {}): {}",
                  name,
                  numGeneratedRecords,
                  numGeneratedRecordsGlobal,
                  record);
              consumer.accept(record);
            },
            delayInNanos,
            delayInNanos,
            TimeUnit.NANOSECONDS);
  }

  public void stop() {
    future.cancel(false);
  }
}
